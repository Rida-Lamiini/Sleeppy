var j = /* @__PURE__ */ ((e) => (e.email = "email", e.profile = "profile", e.openid = "openid", e.offline_access = "offline", e))(j || {}), A = /* @__PURE__ */ ((e) => (e.none = "none", e.create = "create", e.login = "login", e))(A || {}), v = /* @__PURE__ */ ((e) => (e.logout = "logout", e.login = "login", e.register = "registration", e.token = "token", e.profile = "profile", e))(v || {});
const V = (e) => {
  const r = (s) => btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  if (e instanceof ArrayBuffer) {
    const s = new Uint8Array(e), d = String.fromCharCode(...s);
    return r(d);
  }
  const n = new TextEncoder().encode(e), o = String.fromCharCode(...n);
  return r(o);
}, I = (e = 28) => {
  if (crypto) {
    const r = new Uint8Array(e / 2);
    return crypto.getRandomValues(r), Array.from(r, O).join("");
  } else
    return M(e);
};
function O(e) {
  return e.toString(16).padStart(2, "0");
}
function M(e = 28) {
  const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let t = "";
  const n = r.length;
  for (let o = 0; o < e; o++)
    t += r.charAt(Math.floor(Math.random() * n));
  return t;
}
const G = (e) => {
  e = e.split("?")[1];
  const r = new URLSearchParams(e);
  return {
    accessToken: r.get("access_token"),
    idToken: r.get("id_token"),
    expiresIn: +(r.get("expires_in") || 0)
  };
}, E = (e) => e.replace(/\/$/, ""), D = (e) => {
  const r = {
    login_hint: e.loginHint,
    is_create_org: e.isCreateOrg?.toString(),
    connection_id: e.connectionId,
    redirect_uri: e.redirectURL ? E(e.redirectURL) : void 0,
    audience: e.audience || "",
    scope: e.scope?.join(" ") || "email profile openid offline",
    prompt: e.prompt,
    lang: e.lang,
    org_code: e.orgCode,
    org_name: e.orgName,
    has_success_page: e.hasSuccessPage?.toString(),
    workflow_deployment_id: e.workflowDeploymentId
  };
  return Object.keys(r).forEach(
    (t) => r[t] === void 0 && delete r[t]
  ), r;
}, J = async (e, r = v.login, t) => {
  const n = new URL(`${e}/oauth2/auth`), o = L(), s = {
    client_id: t.clientId,
    response_type: t.responseType || "code",
    ...D(t)
  };
  if (t.state || (t.state = I(32), o && o.setSessionItem(c.state, t.state)), s.state = t.state, t.nonce || (t.nonce = I(16)), s.nonce = t.nonce, o && o.setSessionItem(c.nonce, t.nonce), t.codeChallenge)
    s.code_challenge = t.codeChallenge;
  else {
    const { codeVerifier: d, codeChallenge: g } = await F();
    o && o.setSessionItem(c.codeVerifier, d), s.code_challenge = g;
  }
  return s.code_challenge_method = "S256", t.codeChallengeMethod && (s.code_challenge_method = t.codeChallengeMethod), !t.prompt && r === v.register && (s.prompt = A.create), n.search = new URLSearchParams(s).toString(), {
    url: n,
    state: s.state,
    nonce: s.nonce,
    codeChallenge: s.code_challenge
  };
};
async function F() {
  const e = I(52), r = new TextEncoder().encode(e), t = await crypto.subtle.digest("SHA-256", r), n = V(t);
  return { codeVerifier: e, codeChallenge: n };
}
let w;
function U(e, r) {
  if (_(), typeof window > "u")
    throw new Error("setRefreshTimer requires a browser environment");
  if (e <= 0)
    throw new Error("Timer duration must be positive");
  w = window.setTimeout(r, e * 1e3 - 1e4);
}
function _() {
  w !== void 0 && (window.clearTimeout(w), w = void 0);
}
const k = {
  framework: "",
  frameworkVersion: ""
}, W = async ({
  urlParams: e,
  domain: r,
  clientId: t,
  redirectURL: n,
  autoRefresh: o = !1
}) => {
  const s = e.get("state"), d = e.get("code");
  if (!s || !d)
    return console.error("Invalid state or code"), {
      success: !1,
      error: "Invalid state or code"
    };
  const g = L();
  if (!g)
    return console.error("No active storage found"), {
      success: !1,
      error: "Authentication storage is not initialized"
    };
  (!k.framework || !k.frameworkVersion) && console.warn(
    "Framework and version not set. Please set the framework and version in the config object"
  );
  const P = await g.getSessionItem(c.state);
  if (s !== P)
    return console.error("Invalid state"), {
      success: !1,
      error: `Invalid state; supplied ${s}, expected ${P}`
    };
  const R = await g.getSessionItem(
    c.codeVerifier
  ), C = {
    "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
    "Cache-Control": "no-store",
    Pragma: "no-cache"
  };
  k.framework && (C["Kinde-SDK"] = `${k.framework}/${k.frameworkVersion}`);
  const h = await fetch(`${r}/oauth2/token`, {
    method: "POST",
    // ...(isUseCookie && {credentials: 'include'}),
    // credentials: "include",
    headers: new Headers(C),
    body: new URLSearchParams({
      client_id: t,
      code: d,
      code_verifier: R,
      grant_type: "authorization_code",
      redirect_uri: n
    })
  });
  if (!h?.ok) {
    const m = await h.text();
    return console.error("Token exchange failed:", h.status, m), {
      success: !1,
      error: `Token exchange failed: ${h.status} - ${m}`
    };
  }
  _();
  const u = await h.json();
  T().setItems({
    [c.accessToken]: u.access_token,
    [c.idToken]: u.id_token,
    [c.refreshToken]: u.refresh_token
  }), o && U(u.expires_in, async () => {
    p(r, t);
  }), await g.removeItems(
    c.state,
    c.nonce,
    c.codeVerifier
  );
  const N = ((m) => (m.search = "", m))(new URL(window.location.toString()));
  return window.history.replaceState(window.history.state, "", N), {
    success: !0,
    [c.accessToken]: u.access_token,
    [c.idToken]: u.id_token,
    [c.refreshToken]: u.refresh_token
  };
}, Z = (e) => !e.match("^[a-zA-Z]*.kinde.com");
var c = /* @__PURE__ */ ((e) => (e.accessToken = "accessToken", e.idToken = "idToken", e.refreshToken = "refreshToken", e.state = "state", e.nonce = "nonce", e.codeVerifier = "codeVerifier", e))(c || {});
class S {
  async setItems(r) {
    await Promise.all(
      Object.entries(r).map(
        ([t, n]) => this.setSessionItem(t, n)
      )
    );
  }
  async removeItems(...r) {
    await Promise.all(
      r.map((t) => this.removeSessionItem(t))
    );
  }
}
function y(e, r) {
  return r <= 0 ? [] : e.match(new RegExp(`.{1,${r}}`, "g")) || [];
}
class Q extends S {
  memCache = {};
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    this.memCache = {};
  }
  /**
   * Sets the provided key-value store to the memory cache.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(r, t) {
    if (await this.removeSessionItem(r), typeof t == "string") {
      y(t, a.maxLength).forEach(
        (n, o) => {
          this.memCache[`${a.keyPrefix}${r}${o}`] = n;
        }
      );
      return;
    }
    this.memCache[`${a.keyPrefix}${String(r)}0`] = t;
  }
  /**
   * Gets the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(r) {
    if (this.memCache[`${a.keyPrefix}${String(r)}0`] === void 0)
      return null;
    let t = "", n = 0, o = `${a.keyPrefix}${String(r)}${n}`;
    for (; this.memCache[o] !== void 0; )
      t += this.memCache[o], n++, o = `${a.keyPrefix}${String(r)}${n}`;
    return t;
  }
  /**
   * Removes the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {void}
   */
  async removeSessionItem(r) {
    for (const t in this.memCache)
      t.startsWith(`${a.keyPrefix}${String(r)}`) && delete this.memCache[t];
  }
}
function $(e) {
  return new Promise((r, t) => {
    chrome.storage.local.get([e], function(n) {
      chrome.runtime.lastError ? t(void 0) : r(n[e]);
    });
  });
}
class X extends S {
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    await chrome.storage.local.clear();
  }
  /**
   * Sets the provided key-value store to the chrome.store.local.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(r, t) {
    if (await this.removeSessionItem(r), typeof t == "string") {
      y(t, a.maxLength).forEach(
        async (n, o) => {
          await chrome.storage.local.set({
            [`${a.keyPrefix}${r}${o}`]: n
          });
        }
      );
      return;
    }
    await chrome.storage.local.set({
      [`${a.keyPrefix}${r}0`]: t
    });
  }
  /**
   * Gets the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(r) {
    let t = "", n = 0, o = `${a.keyPrefix}${String(r)}${n}`;
    for (; await $(
      `${a.keyPrefix}${String(r)}${n}`
    ) !== void 0; )
      t += await $(o), n++, o = `${a.keyPrefix}${String(r)}${n}`;
    return t;
  }
  /**
   * Removes the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {void}
   */
  async removeSessionItem(r) {
    let t = 0;
    for (; await $(
      `${a.keyPrefix}${String(r)}${t}`
    ) !== void 0; )
      await chrome.storage.local.remove(
        `${a.keyPrefix}${String(r)}${t}`
      ), t++;
  }
}
let l;
async function x() {
  let e = 0;
  for (; !l && e < 20; )
    await new Promise((r) => setTimeout(r, 100)), e++;
}
class Y extends S {
  constructor() {
    super(), this.loadExpoStore();
  }
  async loadExpoStore() {
    try {
      l = await import("expo-secure-store");
    } catch (r) {
      console.error("Error loading dependency expo storage:", r);
    }
  }
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    Object.values(c).forEach(async (t) => {
      await this.removeSessionItem(t);
    });
  }
  /**
   * Sets the provided key-value store to ExpoSecureStore.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(r, t) {
    if (await x(), await this.removeSessionItem(r), typeof t == "string") {
      y(t, Math.min(a.maxLength, 2048)).forEach(
        async (n, o) => {
          await l.setItemAsync(
            `${a.keyPrefix}${r}${o}`,
            n
          );
        }
      );
      return;
    } else
      throw new Error("Item value must be a string");
  }
  /**
   * Gets the item for the provided key from the ExpoSecureStore.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(r) {
    await x();
    const t = [];
    let n = 0, o = await l.getItemAsync(
      `${a.keyPrefix}${String(r)}${n}`
    );
    for (; o; )
      t.push(o), n++, o = await l.getItemAsync(
        `${a.keyPrefix}${String(r)}${n}`
      );
    return t.join("") || null;
  }
  /**
   * Removes the item for the provided key from the ExpoSecureStore.
   * @param {string} itemKey
   * @returns {void}
   */
  async removeSessionItem(r) {
    await x();
    let t = 0, n = await l.getItemAsync(
      `${a.keyPrefix}${String(r)}${t}`
    );
    for (; n; )
      await l.deleteItemAsync(
        `${a.keyPrefix}${String(r)}${t}`
      ), t++, n = await l.getItemAsync(
        `${a.keyPrefix}${String(r)}${t}`
      );
  }
}
class K extends S {
  constructor() {
    super(), console.warn("LocalStorage store should not be used in production");
  }
  internalItems = /* @__PURE__ */ new Set();
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    this.internalItems.forEach((r) => {
      this.removeSessionItem(r);
    });
  }
  /**
   * Sets the provided key-value store to the localStorage cache.
   * @param {V} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(r, t) {
    if (await this.removeSessionItem(r), this.internalItems.add(r), typeof t == "string") {
      y(t, a.maxLength).forEach(
        (n, o) => {
          localStorage.setItem(
            `${a.keyPrefix}${r}${o}`,
            n
          );
        }
      );
      return;
    }
    localStorage.setItem(
      `${a.keyPrefix}${r}0`,
      t
    );
  }
  /**
   * Gets the item for the provided key from the localStorage cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(r) {
    if (localStorage.getItem(`${a.keyPrefix}${r}0`) === null)
      return null;
    let t = "", n = 0, o = `${a.keyPrefix}${String(r)}${n}`;
    for (; localStorage.getItem(o) !== null; )
      t += localStorage.getItem(o), n++, o = `${a.keyPrefix}${String(r)}${n}`;
    return t;
  }
  /**
   * Removes the item for the provided key from the localStorage cache.
   * @param {V} itemKey
   * @returns {void}
   */
  async removeSessionItem(r) {
    let t = 0;
    for (; localStorage.getItem(
      `${a.keyPrefix}${String(r)}${t}`
    ) !== null; )
      localStorage.removeItem(
        `${a.keyPrefix}${String(r)}${t}`
      ), t++;
    this.internalItems.delete(r);
  }
}
const a = {
  /**
   * The prefix to use for the storage keys.
   */
  keyPrefix: "kinde-",
  /**
   * The maximum length of the storage.
   *
   * If the length is exceeded the items will be split into multiple storage items.
   */
  maxLength: 2e3
};
function z(e, r) {
  if (!e)
    return null;
  const t = e.split(".");
  if (t.length !== 3)
    return null;
  const n = t[
    1
    /* body */
  ].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(
    atob(n).split("").map((s) => "%" + ("00" + s.charCodeAt(0).toString(16)).slice(-2)).join("")
  );
  return JSON.parse(o);
}
const f = async (e = c.accessToken) => {
  const r = T();
  if (!r)
    return null;
  const t = await r.getSessionItem(
    e === "accessToken" ? c.accessToken : c.idToken
  );
  if (!t)
    return null;
  const n = z(t);
  return n || console.warn("No decoded token found"), n;
}, q = async () => f("accessToken"), b = async (e) => {
  const r = await q();
  return r ? {
    name: e,
    value: r[e]
  } : null;
}, ee = async () => (await b("org_code"))?.value || null, re = async (e) => {
  const r = (await b("feature_flags"))?.value;
  return e && r && r[e]?.v || null;
}, te = async () => {
  const e = await f("idToken");
  if (!e)
    return null;
  const { sub: r } = e;
  return r ? {
    id: e.sub,
    givenName: e.given_name,
    familyName: e.family_name,
    email: e.email,
    picture: e.picture
  } : (console.error("No sub in idToken"), null);
}, ne = async (e) => {
  const r = await f();
  if (!r)
    return {
      permissionKey: e,
      orgCode: null,
      isGranted: !1
    };
  const t = r.permissions || [];
  return {
    permissionKey: e,
    orgCode: r.org_code,
    isGranted: !!t.includes(e)
  };
}, oe = async () => {
  const e = await f();
  if (!e)
    return {
      orgCode: null,
      permissions: []
    };
  const r = e.permissions || [];
  return {
    orgCode: e.org_code,
    permissions: r
  };
}, se = async () => (await f("idToken"))?.org_codes || null, ae = async () => {
  const e = await f();
  return e ? e.roles ? e.roles : (console.warn(
    "No roles found in token, ensure roles have been included in the token customisation within the application settings"
  ), []) : [];
}, ce = async (e) => {
  try {
    const r = await f("accessToken");
    if (!r) return !1;
    if (!r.exp)
      return console.error("Token does not have an expiry"), !1;
    const t = r.exp < Math.floor(Date.now() / 1e3);
    return t && e?.useRefreshToken ? (await p(e.domain, e.clientId)).success : !t;
  } catch (r) {
    return console.error("Error checking authentication:", r), !1;
  }
}, p = async (e, r) => {
  try {
    if (!e)
      return {
        success: !1,
        error: "Domain is required for token refresh"
      };
    if (!r)
      return {
        success: !1,
        error: "Client ID is required for token refresh"
      };
    const t = T();
    if (!t)
      return {
        success: !1,
        error: "No active storage found"
      };
    const n = await t.getSessionItem(
      c.refreshToken
    );
    if (!n)
      return {
        success: !1,
        error: "No refresh token found"
      };
    _();
    const o = await fetch(`${E(e)}/oauth2/token`, {
      method: "POST",
      headers: {
        "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        "Cache-Control": "no-store",
        Pragma: "no-cache"
      },
      body: new URLSearchParams({
        refresh_token: n,
        grant_type: "refresh_token",
        client_id: r
      })
    });
    if (!o.ok)
      return {
        success: !1,
        error: "Failed to refresh token"
      };
    const s = await o.json();
    return s.access_token ? (U(s.expires_in, async () => {
      p(e, r);
    }), await t.setSessionItem(c.accessToken, s.access_token), s.id_token && await t.setSessionItem(c.idToken, s.id_token), s.refresh_token && await t.setSessionItem(
      c.refreshToken,
      s.refresh_token
    ), {
      success: !0,
      [c.accessToken]: s.access_token,
      [c.idToken]: s.id_token,
      [c.refreshToken]: s.refresh_token
    }) : {
      success: !1,
      error: "No access token recieved"
    };
  } catch (t) {
    return {
      success: !1,
      error: `Error refreshing token: ${t}`
    };
  }
}, i = {
  secure: null,
  insecure: null
}, ie = (e) => {
  i.secure = e;
}, T = () => i.secure || null, le = () => i.secure !== null, ue = () => {
  i.secure = null;
}, fe = (e) => {
  i.insecure = e;
}, L = () => i.insecure || i.secure || null, de = () => i.insecure !== null, ge = () => {
  i.insecure = null;
};
export {
  X as ChromeStore,
  Y as ExpoSecureStore,
  v as IssuerRouteTypes,
  K as LocalStorage,
  Q as MemoryStorage,
  A as PromptTypes,
  j as Scopes,
  c as StorageKeys,
  V as base64UrlEncode,
  ue as clearActiveStorage,
  ge as clearInsecureStorage,
  W as exchangeAuthCode,
  G as extractAuthResults,
  k as frameworkSettings,
  J as generateAuthUrl,
  I as generateRandomString,
  T as getActiveStorage,
  b as getClaim,
  q as getClaims,
  ee as getCurrentOrganization,
  f as getDecodedToken,
  re as getFlag,
  L as getInsecureStorage,
  ne as getPermission,
  oe as getPermissions,
  ae as getRoles,
  se as getUserOrganizations,
  te as getUserProfile,
  le as hasActiveStorage,
  de as hasInsecureStorage,
  ce as isAuthenticated,
  Z as isCustomDomain,
  D as mapLoginMethodParamsForUrl,
  p as refreshToken,
  E as sanitizeUrl,
  ie as setActiveStorage,
  fe as setInsecureStorage,
  a as storageSettings
};
